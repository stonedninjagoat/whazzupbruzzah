<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MIDI Pattern Extractor</title>
</head>
<body>
  <h1>MIDI Pattern Extractor</h1>
  <input type="file" id="csvInput" accept=".csv" />
  <button onclick="downloadCSV()">Download CSV</button>
  <pre id="output"></pre>

  <script>
    let transformedPositions = [];
    let transformedMIDIs = [];
    let chords = [];
    let intervals = [];
    let patterns = [];

    document.getElementById("csvInput").addEventListener("change", function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        const text = e.target.result;
        const rows = text.trim().split("\n").slice(1); // Skip header
        const positionMap = {};

        for (const row of rows) {
          const parts = row.split(",");
          const position = parseFloat(parts[1]);
          const midi = parseInt(parts[3]);

          if (!positionMap[position]) positionMap[position] = [];
          positionMap[position].push(midi);
        }

        transformedPositions = [];
        transformedMIDIs = [];
        chords = [];

        for (const pos in positionMap) {
          const notes = positionMap[pos];
          if (notes.length === 1) {
            transformedPositions.push(parseFloat(pos));
            transformedMIDIs.push(notes[0]);
          } else {
            chords.push(notes.sort((a, b) => a - b));
          }
        }

        // Generate intervals
        intervals = [];
        for (let i = 1; i < transformedMIDIs.length; i++) {
          intervals.push(transformedMIDIs[i] - transformedMIDIs[i - 1]);
        }

        // Pattern detection
        patterns = extractPatterns(intervals);

        // Output
        document.getElementById("output").textContent =
          "Intervals:\n" + intervals.join(", ") +
          "\n\nChords:\n" + JSON.stringify(chords, null, 2) +
          "\n\nPatterns:\n" + JSON.stringify(patterns, null, 2);
      };
      reader.readAsText(file);
    });

    function extractPatterns(intervals) {
      const maxLen = Math.min(5, intervals.length); // Max pattern length
      const seen = new Set();
      const patterns = [];

      for (let len = maxLen; len >= 2; len--) {
        for (let i = 0; i <= intervals.length - len; i++) {
          const slice = intervals.slice(i, i + len);
          const key = slice.join("_");

          if (!seen.has(key)) {
            let count = 0;
            for (let j = 0; j <= intervals.length - len; j++) {
              const testSlice = intervals.slice(j, j + len).join("_");
              if (testSlice === key) count++;
            }
            if (count > 1) {
              seen.add(key);
              patterns.push(slice);
            }
          }
        }
      }

      return patterns;
    }

    function downloadCSV() {
      const headers = ["Position", "MIDI", "Interval"];
      const rows = [headers.join(",")];

      for (let i = 0; i < transformedMIDIs.length; i++) {
        const pos = transformedPositions[i] || "";
        const midi = transformedMIDIs[i];
        const intv = intervals[i - 1] ?? "";
        rows.push([pos, midi, intv].join(","));
      }

      const patternHeader = "\n\nPatterns:";
      const patternLines = patterns.map(p => p.join(" ")).join("\n");

      const blob = new Blob([rows.join("\n") + patternHeader + "\n" + patternLines], { type: "text/csv" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "intervals_patterns.csv";
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
