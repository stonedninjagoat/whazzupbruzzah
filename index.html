<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Melodic Pattern Extractor</title>
</head>
<body>
  <h1>Melodic Pattern Extractor</h1>
  <input type="file" id="fileInput" accept=".csv" />
  <button onclick="exportPatterns()">Export Patterns CSV</button>
  <pre id="output"></pre>

  <script>
    let patterns = [];

    document.getElementById("fileInput").addEventListener("change", function (e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (event) {
        const text = event.target.result;
        const lines = text.trim().split("\n");
        const midiNumbers = [];

        // Skip header, parse MIDI column (assumes it's labeled 'MIDI')
        const headers = lines[0].split(",");
        const midiIndex = headers.findIndex(h => h.trim().toLowerCase().includes("midi"));

        for (let i = 1; i < lines.length; i++) {
          const cols = lines[i].split(",");
          midiNumbers.push(parseInt(cols[midiIndex]));
        }

        const intervals = getIntervals(midiNumbers);
        patterns = extractPatterns(intervals);

        document.getElementById("output").textContent =
          "MIDI: " + midiNumbers.join(", ") + "\n" +
          "Intervals: " + intervals.join(", ") + "\n\n" +
          "Patterns:\n" + JSON.stringify(patterns, null, 2);
      };
      reader.readAsText(file);
    });

    function getIntervals(midiArray) {
      const intervals = [];
      for (let i = 1; i < midiArray.length; i++) {
        intervals.push(midiArray[i] - midiArray[i - 1]);
      }
      return intervals;
    }

    function extractPatterns(intervals) {
      const seen = {};
      const groups = [];

      for (let i = 0; i < intervals.length; i++) {
        for (let len = 3; len >= 2; len--) {
          if (i + len > intervals.length) continue;
          const slice = intervals.slice(i, i + len).join(",");
          if (seen[slice] !== undefined) {
            groups.push(intervals.slice(i, i + len));
            i += len - 1;
            break;
          } else {
            seen[slice] = true;
          }
        }
      }

      // Add any remaining ungrouped intervals
      let cursor = 0;
      let covered = new Array(intervals.length).fill(false);
      for (let g of groups) {
        const idx = intervals.join(",").indexOf(g.join(","));
        for (let i = 0; i < g.length; i++) {
          covered[cursor + i] = true;
        }
        cursor += g.length;
      }

      let leftover = [];
      for (let i = 0; i < intervals.length; i++) {
        if (!covered[i]) leftover.push([intervals[i]]);
      }

      return [...groups, ...leftover];
    }

    function exportPatterns() {
      if (patterns.length === 0) return alert("No patterns to export.");

      let csvContent = "data:text/csv;charset=utf-8,PatternID,Pattern\n";
      patterns.forEach((pattern, idx) => {
        csvContent += `${idx + 1},"${pattern.join(' ')}"\n`;
      });

      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "patterns.csv");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  </script>
</body>
</html>
