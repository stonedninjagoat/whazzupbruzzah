<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MIDI Pattern Extractor</title>
</head>
<body>
  <h2>MIDI Pattern Extractor Tool</h2>
  <input type="file" id="csvFile" accept=".csv">
  <div>
    <label>Min Motif Length: <input type="number" id="minLength" value="2"></label>
    <label>Max Motif Length: <input type="number" id="maxLength" value="6"></label>
    <label>Min Frequency: <input type="number" id="minCount" value="2"></label>
  </div>
  <button onclick="processCSV()">Process MIDI CSV</button>
  <button onclick="downloadPatterns()">Download Patterns CSV</button>
  <button onclick="findMotifs()">Find Motifs (n-grams)</button>
  <pre id="output"></pre>

  <script>
    let patternsDict = [];
    let globalIntervals = [];
    let chordsGlobal = [];
    let motifStats = [];

    function parseCSV(text) {
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',');
      const posIndex = headers.findIndex(h => h.trim().toLowerCase().includes("position"));
      const midiIndex = headers.findIndex(h => h.trim().toLowerCase().includes("midi"));

      return lines.slice(1).map(line => {
        const parts = line.split(',');
        return {
          position: parseFloat(parts[posIndex]),
          midi: parseInt(parts[midiIndex])
        };
      });
    }

    function groupNotes(data) {
      const chords = [];
      const transformedPositions = [];
      const transformedMIDIs = [];

      const grouped = data.reduce((acc, note) => {
        const key = note.position.toFixed(5);
        if (!acc[key]) acc[key] = [];
        acc[key].push(note.midi);
        return acc;
      }, {});

      for (const [pos, notes] of Object.entries(grouped)) {
        if (notes.length === 1) {
          transformedPositions.push(parseFloat(pos));
          transformedMIDIs.push(notes[0]);
        } else {
          chords.push(notes);
        }
      }

      chordsGlobal = chords;
      return { transformedPositions, transformedMIDIs };
    }

    function getIntervals(midiList) {
      const intervals = [];
      for (let i = 1; i < midiList.length; i++) {
        intervals.push(midiList[i] - midiList[i - 1]);
      }
      return intervals;
    }

    function processCSV() {
      const fileInput = document.getElementById('csvFile');
      const reader = new FileReader();

      reader.onload = function (e) {
        const text = e.target.result;
        const parsedData = parseCSV(text);
        const { transformedPositions, transformedMIDIs } = groupNotes(parsedData);
        const intervals = getIntervals(transformedMIDIs);
        globalIntervals = intervals;
        patternsDict = [];

        document.getElementById('output').textContent =
          `Transformed Positions:\n${JSON.stringify(transformedPositions)}\n\n` +
          `Transformed MIDIs:\n${JSON.stringify(transformedMIDIs)}\n\n` +
          `Chords:\n${JSON.stringify(chordsGlobal)}\n\n` +
          `Intervals:\n${JSON.stringify(intervals)}`;
      };

      if (fileInput.files.length > 0) {
        reader.readAsText(fileInput.files[0]);
      } else {
        alert("Please upload a CSV file first.");
      }
    }

    function downloadPatterns() {
      if (!motifStats.length) {
        alert("No patterns to export.");
        return;
      }

      let csv = 'Motif,Count,Length,Significance\n';
      csv += motifStats.map(m => `"${m.pattern}",${m.count},${m.length},${m.significance.toFixed(4)}`).join('\n');

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'motif_patterns.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    function findMotifs() {
      if (!globalIntervals.length) {
        alert("Please process a MIDI CSV first.");
        return;
      }

      const minCount = parseInt(document.getElementById('minCount').value);
      const minLength = parseInt(document.getElementById('minLength').value);
      const maxLength = parseInt(document.getElementById('maxLength').value);

      const intervals = globalIntervals;
      const motifMap = new Map();

      for (let n = minLength; n <= maxLength; n++) {
        for (let i = 0; i <= intervals.length - n; i++) {
          const gram = intervals.slice(i, i + n).join(',');
          motifMap.set(gram, (motifMap.get(gram) || 0) + 1);
        }
      }

      const totalLength = intervals.length;
      motifStats = [...motifMap.entries()]
        .filter(([_, count]) => count >= minCount)
        .map(([pattern, count]) => {
          const length = pattern.split(',').length;
          const significance = (count * length) / totalLength;
          return { pattern, count, length, significance };
        })
        .sort((a, b) => b.significance - a.significance);

      const motifsOutput = motifStats.map(m => `Motif: [${m.pattern}] | Count: ${m.count} | Length: ${m.length} | Significance: ${m.significance.toFixed(4)}`).join('\n');

      document.getElementById('output').textContent += `\n\nMotifs (n-grams with freq >= ${minCount}):\n${motifsOutput}`;
    }
  </script>
</body>
</html>
