<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MIDI Pattern Extractor</title>
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.min.js"></script>
</head>
<body>
  <h1>MIDI Pattern Extractor</h1>
  <input type="file" id="fileInput" accept=".mid" />
  <button id="downloadCSV">Download Patterns CSV</button>
  <pre id="output"></pre>

  <script>
    document.getElementById('fileInput').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const arrayBuffer = await file.arrayBuffer();
      const midi = new Midi(arrayBuffer);

      const notes = [];
      midi.tracks.forEach(track => {
        track.notes.forEach(note => {
          notes.push({ time: note.time, midi: note.midi });
        });
      });

      // Keep highest MIDI note per time
      const timeToNote = {};
      notes.forEach(({ time, midi }) => {
        if (!(time in timeToNote) || midi > timeToNote[time]) {
          timeToNote[time] = midi;
        }
      });

      const filtered = Object.entries(timeToNote)
        .map(([time, midi]) => ({ time: parseFloat(time), midi }))
        .sort((a, b) => a.time - b.time);

      const pitches = filtered.map(n => n.midi);

      // Convert to intervals
      const intervals = [];
      for (let i = 1; i < pitches.length; i++) {
        intervals.push(pitches[i] - pitches[i - 1]);
      }

      // Find repeating patterns that minimize group count
      function findPatterns(seq) {
        const patterns = [];
        const seen = new Map();

        let i = 0;
        while (i < seq.length) {
          let longestMatch = [];
          for (let len = seq.length - i; len >= 1; len--) {
            const candidate = seq.slice(i, i + len).join(',');
            if (seen.has(candidate)) {
              longestMatch = seen.get(candidate);
              break;
            }
            const firstIndex = seq.join(',').indexOf(candidate);
            const secondIndex = seq.join(',').indexOf(candidate, firstIndex + 1);
            if (secondIndex !== -1) {
              seen.set(candidate, seq.slice(i, i + len));
              longestMatch = seq.slice(i, i + len);
              break;
            }
          }
          if (longestMatch.length > 0) {
            patterns.push(longestMatch);
            i += longestMatch.length;
          } else {
            patterns.push([seq[i]]);
            i++;
          }
        }

        // Deduplicate patterns
        const unique = [];
        const added = new Set();
        for (const p of patterns) {
          const key = p.join(',');
          if (!added.has(key)) {
            unique.push(p);
            added.add(key);
          }
        }
        return unique;
      }

      const patterns = findPatterns(intervals);

      // Output result
      const out = document.getElementById('output');
      out.textContent = `Intervals: [${intervals.join(', ')}]\n\nPatterns:\n` +
        patterns.map(p => `[${p.join(', ')}]`).join('\n');

      // Download CSV
      document.getElementById('downloadCSV').onclick = () => {
        let csv = 'Pattern\n';
        patterns.forEach(p => {
          csv += `"${p.join(',')}"\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'patterns.csv';
        a.click();
        URL.revokeObjectURL(url);
      };
    });
  </script>
</body>
</html>
