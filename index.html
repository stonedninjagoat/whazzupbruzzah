<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MIDI Pattern Extractor</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    textarea { width: 100%; height: 200px; }
    button { margin-top: 10px; }
  </style>
</head>
<body>

<h2>MIDI Pattern Extractor</h2>
<input type="file" id="fileInput" accept=".csv" />
<button onclick="downloadCSV()">Download Pattern CSV</button>
<pre id="output"></pre>

<script>
let patternDictionary = [];

document.getElementById('fileInput').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(event) {
    const text = event.target.result;
    processCSV(text);
  };
  reader.readAsText(file);
});

function processCSV(csv) {
  const lines = csv.trim().split('\n');
  const headers = lines[0].split(',');
  const posIndex = headers.findIndex(h => h.toLowerCase().includes('position'));
  const midiIndex = headers.findIndex(h => h.toLowerCase().includes('midi'));

  const data = lines.slice(1).map(line => {
    const cells = line.split(',');
    return { pos: parseFloat(cells[posIndex]), midi: parseInt(cells[midiIndex]) };
  });

  // Step 1: Deduplicate by position, keep highest MIDI
  const filtered = Object.values(data.reduce((acc, { pos, midi }) => {
    if (!acc[pos] || acc[pos].midi < midi) acc[pos] = { pos, midi };
    return acc;
  }, {})).sort((a, b) => a.pos - b.pos);

  const midiSequence = filtered.map(d => d.midi);

  // Step 2: Convert MIDI to interval sequence
  const intervals = [];
  for (let i = 1; i < midiSequence.length; i++) {
    intervals.push(midiSequence[i] - midiSequence[i - 1]);
  }

  // Step 3: Pattern extraction using greedy match
  const patterns = [];
  let i = 0;
  while (i < intervals.length) {
    let found = false;
    for (let len = Math.min(5, intervals.length - i); len >= 2; len--) {
      const candidate = intervals.slice(i, i + len);
      const firstIndex = findSubArray(intervals, candidate, 0);
      const secondIndex = findSubArray(intervals, candidate, i + 1);
      if (secondIndex !== -1) {
        patterns.push(candidate);
        i += len;
        found = true;
        break;
      }
    }
    if (!found) {
      patterns.push([intervals[i]]);
      i++;
    }
  }

  patternDictionary = patterns;

  document.getElementById('output').textContent =
    'Filtered MIDI: ' + JSON.stringify(midiSequence) + '\n\n' +
    'Intervals: ' + JSON.stringify(intervals) + '\n\n' +
    'Patterns:\n' + patterns.map(p => JSON.stringify(p)).join('\n');
}

// Utility: find a subarray in array
function findSubArray(arr, sub, from = 0) {
  for (let i = from; i <= arr.length - sub.length; i++) {
    if (arr.slice(i, i + sub.length).join(',') === sub.join(',')) {
      return i;
    }
  }
  return -1;
}

// Download patterns as CSV
function downloadCSV() {
  if (!patternDictionary.length) return alert("No patterns to download!");
  const csv = patternDictionary.map(p => p.join(' ')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'patterns.csv';
  a.click();
  URL.revokeObjectURL(url);
}
</script>

</body>
</html>
