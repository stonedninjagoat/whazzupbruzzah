<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MIDI Pattern Extractor</title>
</head>
<body>
  <h2>MIDI Pattern Extractor Tool</h2>
  <input type="file" id="csvFile" accept=".csv">
  <button onclick="processCSV()">Process MIDI CSV</button>
  <button onclick="downloadPatterns()">Download Patterns CSV</button>
  <button onclick="findMotifs()">Find Motifs (n-grams)</button>
  <pre id="output"></pre>

  <script>
    let patternsDict = [];
    let globalIntervals = [];

    function parseCSV(text) {
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',');
      const posIndex = headers.findIndex(h => h.trim().toLowerCase().includes("position"));
      const midiIndex = headers.findIndex(h => h.trim().toLowerCase().includes("midi"));

      return lines.slice(1).map(line => {
        const parts = line.split(',');
        return {
          position: parseFloat(parts[posIndex]),
          midi: parseInt(parts[midiIndex])
        };
      });
    }

    function groupNotes(data) {
      const chords = [];
      const transformedPositions = [];
      const transformedMIDIs = [];

      const grouped = data.reduce((acc, note) => {
        const key = note.position.toFixed(5);
        if (!acc[key]) acc[key] = [];
        acc[key].push(note.midi);
        return acc;
      }, {});

      for (const [pos, notes] of Object.entries(grouped)) {
        if (notes.length === 1) {
          transformedPositions.push(parseFloat(pos));
          transformedMIDIs.push(notes[0]);
        } else {
          chords.push(notes);
        }
      }

      return { transformedPositions, transformedMIDIs, chords };
    }

    function getIntervals(midiList) {
      const intervals = [];
      for (let i = 1; i < midiList.length; i++) {
        intervals.push(midiList[i] - midiList[i - 1]);
      }
      return intervals;
    }

    function findPatterns(intervals) {
      const maxLen = Math.floor(intervals.length / 2);
      const patterns = new Set();

      for (let len = maxLen; len >= 2; len--) {
        for (let i = 0; i <= intervals.length - len; i++) {
          const pattern = intervals.slice(i, i + len).join(',');
          const count = intervals.join(',').split(pattern).length - 1;
          if (count > 1) patterns.add(pattern);
        }
      }

      return Array.from(patterns).map(p => p.split(',').map(Number));
    }

    function processCSV() {
      const fileInput = document.getElementById('csvFile');
      const reader = new FileReader();

      reader.onload = function (e) {
        const text = e.target.result;
        const parsedData = parseCSV(text);
        const { transformedPositions, transformedMIDIs, chords } = groupNotes(parsedData);
        const intervals = getIntervals(transformedMIDIs);
        globalIntervals = intervals;
        const patterns = findPatterns(intervals);
        patternsDict = patterns;

        document.getElementById('output').textContent =
          `Transformed Positions:\n${JSON.stringify(transformedPositions)}\n\n` +
          `Transformed MIDIs:\n${JSON.stringify(transformedMIDIs)}\n\n` +
          `Chords:\n${JSON.stringify(chords)}\n\n` +
          `Intervals:\n${JSON.stringify(intervals)}\n\n` +
          `Patterns:\n${JSON.stringify(patternsDict)}`;
      };

      if (fileInput.files.length > 0) {
        reader.readAsText(fileInput.files[0]);
      } else {
        alert("Please upload a CSV file first.");
      }
    }

    function downloadPatterns() {
      if (!patternsDict.length) {
        alert("No patterns to export.");
        return;
      }

      const csv = patternsDict.map(p => p.join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'patterns.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    function findMotifs() {
      if (!globalIntervals.length) {
        alert("Please process a MIDI CSV first.");
        return;
      }

      const intervals = globalIntervals;
      const minCount = 2;
      const minLength = 2;
      const maxLength = 6;

      const motifMap = new Map();

      for (let n = minLength; n <= maxLength; n++) {
        for (let i = 0; i <= intervals.length - n; i++) {
          const gram = intervals.slice(i, i + n).join(',');
          motifMap.set(gram, (motifMap.get(gram) || 0) + 1);
        }
      }

      const filtered = [...motifMap.entries()]
        .filter(([_, count]) => count >= minCount)
        .sort((a, b) => b[1] - a[1]);

      const motifsOutput = filtered.map(([gram, count]) => `Motif: [${gram}] x ${count}`).join('\n');

      document.getElementById('output').textContent += `\n\nMotifs (n-grams with freq >= ${minCount}):\n${motifsOutput}`;
    }
  </script>
</body>
</html>
